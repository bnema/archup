// Code generated by MockGen. DO NOT EDIT.
// Source: /home/brice/dev/projects/archup/internal/interfaces/interfaces.go
//
// Generated by this command:
//
//	mockgen -source=/home/brice/dev/projects/archup/internal/interfaces/interfaces.go -destination=/home/brice/dev/projects/archup/internal/interfaces/mocks/mock_interfaces.go -package=mocks
//

// Package mocks is a generated GoMock package.
package mocks

import (
	io "io"
	http "net/http"
	os "os"
	reflect "reflect"

	system "github.com/bnema/archup/internal/system"
	gomock "go.uber.org/mock/gomock"
)

// MockFileSystem is a mock of FileSystem interface.
type MockFileSystem struct {
	ctrl     *gomock.Controller
	recorder *MockFileSystemMockRecorder
	isgomock struct{}
}

// MockFileSystemMockRecorder is the mock recorder for MockFileSystem.
type MockFileSystemMockRecorder struct {
	mock *MockFileSystem
}

// NewMockFileSystem creates a new mock instance.
func NewMockFileSystem(ctrl *gomock.Controller) *MockFileSystem {
	mock := &MockFileSystem{ctrl: ctrl}
	mock.recorder = &MockFileSystemMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockFileSystem) EXPECT() *MockFileSystemMockRecorder {
	return m.recorder
}

// Chmod mocks base method.
func (m *MockFileSystem) Chmod(name string, mode os.FileMode) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Chmod", name, mode)
	ret0, _ := ret[0].(error)
	return ret0
}

// Chmod indicates an expected call of Chmod.
func (mr *MockFileSystemMockRecorder) Chmod(name, mode any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Chmod", reflect.TypeOf((*MockFileSystem)(nil).Chmod), name, mode)
}

// Create mocks base method.
func (m *MockFileSystem) Create(name string) (io.WriteCloser, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Create", name)
	ret0, _ := ret[0].(io.WriteCloser)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Create indicates an expected call of Create.
func (mr *MockFileSystemMockRecorder) Create(name any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Create", reflect.TypeOf((*MockFileSystem)(nil).Create), name)
}

// IsNotExist mocks base method.
func (m *MockFileSystem) IsNotExist(err error) bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsNotExist", err)
	ret0, _ := ret[0].(bool)
	return ret0
}

// IsNotExist indicates an expected call of IsNotExist.
func (mr *MockFileSystemMockRecorder) IsNotExist(err any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsNotExist", reflect.TypeOf((*MockFileSystem)(nil).IsNotExist), err)
}

// MkdirAll mocks base method.
func (m *MockFileSystem) MkdirAll(path string, perm os.FileMode) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "MkdirAll", path, perm)
	ret0, _ := ret[0].(error)
	return ret0
}

// MkdirAll indicates an expected call of MkdirAll.
func (mr *MockFileSystemMockRecorder) MkdirAll(path, perm any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "MkdirAll", reflect.TypeOf((*MockFileSystem)(nil).MkdirAll), path, perm)
}

// Open mocks base method.
func (m *MockFileSystem) Open(name string) (io.ReadCloser, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Open", name)
	ret0, _ := ret[0].(io.ReadCloser)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Open indicates an expected call of Open.
func (mr *MockFileSystemMockRecorder) Open(name any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Open", reflect.TypeOf((*MockFileSystem)(nil).Open), name)
}

// ReadFile mocks base method.
func (m *MockFileSystem) ReadFile(filename string) ([]byte, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ReadFile", filename)
	ret0, _ := ret[0].([]byte)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ReadFile indicates an expected call of ReadFile.
func (mr *MockFileSystemMockRecorder) ReadFile(filename any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ReadFile", reflect.TypeOf((*MockFileSystem)(nil).ReadFile), filename)
}

// RemoveAll mocks base method.
func (m *MockFileSystem) RemoveAll(path string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "RemoveAll", path)
	ret0, _ := ret[0].(error)
	return ret0
}

// RemoveAll indicates an expected call of RemoveAll.
func (mr *MockFileSystemMockRecorder) RemoveAll(path any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RemoveAll", reflect.TypeOf((*MockFileSystem)(nil).RemoveAll), path)
}

// Stat mocks base method.
func (m *MockFileSystem) Stat(name string) (os.FileInfo, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Stat", name)
	ret0, _ := ret[0].(os.FileInfo)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Stat indicates an expected call of Stat.
func (mr *MockFileSystemMockRecorder) Stat(name any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Stat", reflect.TypeOf((*MockFileSystem)(nil).Stat), name)
}

// WriteFile mocks base method.
func (m *MockFileSystem) WriteFile(filename string, data []byte, perm os.FileMode) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "WriteFile", filename, data, perm)
	ret0, _ := ret[0].(error)
	return ret0
}

// WriteFile indicates an expected call of WriteFile.
func (mr *MockFileSystemMockRecorder) WriteFile(filename, data, perm any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "WriteFile", reflect.TypeOf((*MockFileSystem)(nil).WriteFile), filename, data, perm)
}

// MockCommandExecutor is a mock of CommandExecutor interface.
type MockCommandExecutor struct {
	ctrl     *gomock.Controller
	recorder *MockCommandExecutorMockRecorder
	isgomock struct{}
}

// MockCommandExecutorMockRecorder is the mock recorder for MockCommandExecutor.
type MockCommandExecutorMockRecorder struct {
	mock *MockCommandExecutor
}

// NewMockCommandExecutor creates a new mock instance.
func NewMockCommandExecutor(ctrl *gomock.Controller) *MockCommandExecutor {
	mock := &MockCommandExecutor{ctrl: ctrl}
	mock.recorder = &MockCommandExecutorMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockCommandExecutor) EXPECT() *MockCommandExecutorMockRecorder {
	return m.recorder
}

// Execute mocks base method.
func (m *MockCommandExecutor) Execute(name string, args ...string) ([]byte, error) {
	m.ctrl.T.Helper()
	varargs := []any{name}
	for _, a := range args {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Execute", varargs...)
	ret0, _ := ret[0].([]byte)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Execute indicates an expected call of Execute.
func (mr *MockCommandExecutorMockRecorder) Execute(name any, args ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{name}, args...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Execute", reflect.TypeOf((*MockCommandExecutor)(nil).Execute), varargs...)
}

// MockSystemExecutor is a mock of SystemExecutor interface.
type MockSystemExecutor struct {
	ctrl     *gomock.Controller
	recorder *MockSystemExecutorMockRecorder
	isgomock struct{}
}

// MockSystemExecutorMockRecorder is the mock recorder for MockSystemExecutor.
type MockSystemExecutorMockRecorder struct {
	mock *MockSystemExecutor
}

// NewMockSystemExecutor creates a new mock instance.
func NewMockSystemExecutor(ctrl *gomock.Controller) *MockSystemExecutor {
	mock := &MockSystemExecutor{ctrl: ctrl}
	mock.recorder = &MockSystemExecutorMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockSystemExecutor) EXPECT() *MockSystemExecutorMockRecorder {
	return m.recorder
}

// DetectCPUInfo mocks base method.
func (m *MockSystemExecutor) DetectCPUInfo() (*system.CPUInfo, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "DetectCPUInfo")
	ret0, _ := ret[0].(*system.CPUInfo)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// DetectCPUInfo indicates an expected call of DetectCPUInfo.
func (mr *MockSystemExecutorMockRecorder) DetectCPUInfo() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DetectCPUInfo", reflect.TypeOf((*MockSystemExecutor)(nil).DetectCPUInfo))
}

// RunSimple mocks base method.
func (m *MockSystemExecutor) RunSimple(command string, args ...string) system.CommandResult {
	m.ctrl.T.Helper()
	varargs := []any{command}
	for _, a := range args {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "RunSimple", varargs...)
	ret0, _ := ret[0].(system.CommandResult)
	return ret0
}

// RunSimple indicates an expected call of RunSimple.
func (mr *MockSystemExecutorMockRecorder) RunSimple(command any, args ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{command}, args...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RunSimple", reflect.TypeOf((*MockSystemExecutor)(nil).RunSimple), varargs...)
}

// MockChrootExecutor is a mock of ChrootExecutor interface.
type MockChrootExecutor struct {
	ctrl     *gomock.Controller
	recorder *MockChrootExecutorMockRecorder
	isgomock struct{}
}

// MockChrootExecutorMockRecorder is the mock recorder for MockChrootExecutor.
type MockChrootExecutorMockRecorder struct {
	mock *MockChrootExecutor
}

// NewMockChrootExecutor creates a new mock instance.
func NewMockChrootExecutor(ctrl *gomock.Controller) *MockChrootExecutor {
	mock := &MockChrootExecutor{ctrl: ctrl}
	mock.recorder = &MockChrootExecutorMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockChrootExecutor) EXPECT() *MockChrootExecutorMockRecorder {
	return m.recorder
}

// ChrootExec mocks base method.
func (m *MockChrootExecutor) ChrootExec(logPath, mountPoint, command string, args ...string) error {
	m.ctrl.T.Helper()
	varargs := []any{logPath, mountPoint, command}
	for _, a := range args {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ChrootExec", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// ChrootExec indicates an expected call of ChrootExec.
func (mr *MockChrootExecutorMockRecorder) ChrootExec(logPath, mountPoint, command any, args ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{logPath, mountPoint, command}, args...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ChrootExec", reflect.TypeOf((*MockChrootExecutor)(nil).ChrootExec), varargs...)
}

// ChrootExecWithStdin mocks base method.
func (m *MockChrootExecutor) ChrootExecWithStdin(logPath, mountPoint, command, stdin string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ChrootExecWithStdin", logPath, mountPoint, command, stdin)
	ret0, _ := ret[0].(error)
	return ret0
}

// ChrootExecWithStdin indicates an expected call of ChrootExecWithStdin.
func (mr *MockChrootExecutorMockRecorder) ChrootExecWithStdin(logPath, mountPoint, command, stdin any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ChrootExecWithStdin", reflect.TypeOf((*MockChrootExecutor)(nil).ChrootExecWithStdin), logPath, mountPoint, command, stdin)
}

// ChrootPacman mocks base method.
func (m *MockChrootExecutor) ChrootPacman(logPath, mountPoint, operation string, packages ...string) error {
	m.ctrl.T.Helper()
	varargs := []any{logPath, mountPoint, operation}
	for _, a := range packages {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ChrootPacman", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// ChrootPacman indicates an expected call of ChrootPacman.
func (mr *MockChrootExecutorMockRecorder) ChrootPacman(logPath, mountPoint, operation any, packages ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{logPath, mountPoint, operation}, packages...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ChrootPacman", reflect.TypeOf((*MockChrootExecutor)(nil).ChrootPacman), varargs...)
}

// ChrootSystemctl mocks base method.
func (m *MockChrootExecutor) ChrootSystemctl(logPath, mountPoint, action, service string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ChrootSystemctl", logPath, mountPoint, action, service)
	ret0, _ := ret[0].(error)
	return ret0
}

// ChrootSystemctl indicates an expected call of ChrootSystemctl.
func (mr *MockChrootExecutorMockRecorder) ChrootSystemctl(logPath, mountPoint, action, service any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ChrootSystemctl", reflect.TypeOf((*MockChrootExecutor)(nil).ChrootSystemctl), logPath, mountPoint, action, service)
}

// DownloadAndInstallPackages mocks base method.
func (m *MockChrootExecutor) DownloadAndInstallPackages(logPath, chrootPath string, urls ...string) error {
	m.ctrl.T.Helper()
	varargs := []any{logPath, chrootPath}
	for _, a := range urls {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "DownloadAndInstallPackages", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// DownloadAndInstallPackages indicates an expected call of DownloadAndInstallPackages.
func (mr *MockChrootExecutorMockRecorder) DownloadAndInstallPackages(logPath, chrootPath any, urls ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{logPath, chrootPath}, urls...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DownloadAndInstallPackages", reflect.TypeOf((*MockChrootExecutor)(nil).DownloadAndInstallPackages), varargs...)
}

// MockHTTPClient is a mock of HTTPClient interface.
type MockHTTPClient struct {
	ctrl     *gomock.Controller
	recorder *MockHTTPClientMockRecorder
	isgomock struct{}
}

// MockHTTPClientMockRecorder is the mock recorder for MockHTTPClient.
type MockHTTPClientMockRecorder struct {
	mock *MockHTTPClient
}

// NewMockHTTPClient creates a new mock instance.
func NewMockHTTPClient(ctrl *gomock.Controller) *MockHTTPClient {
	mock := &MockHTTPClient{ctrl: ctrl}
	mock.recorder = &MockHTTPClientMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockHTTPClient) EXPECT() *MockHTTPClientMockRecorder {
	return m.recorder
}

// Get mocks base method.
func (m *MockHTTPClient) Get(url string) (*http.Response, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Get", url)
	ret0, _ := ret[0].(*http.Response)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Get indicates an expected call of Get.
func (mr *MockHTTPClientMockRecorder) Get(url any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Get", reflect.TypeOf((*MockHTTPClient)(nil).Get), url)
}

// MockConfigSaver is a mock of ConfigSaver interface.
type MockConfigSaver struct {
	ctrl     *gomock.Controller
	recorder *MockConfigSaverMockRecorder
	isgomock struct{}
}

// MockConfigSaverMockRecorder is the mock recorder for MockConfigSaver.
type MockConfigSaverMockRecorder struct {
	mock *MockConfigSaver
}

// NewMockConfigSaver creates a new mock instance.
func NewMockConfigSaver(ctrl *gomock.Controller) *MockConfigSaver {
	mock := &MockConfigSaver{ctrl: ctrl}
	mock.recorder = &MockConfigSaverMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockConfigSaver) EXPECT() *MockConfigSaverMockRecorder {
	return m.recorder
}

// Save mocks base method.
func (m *MockConfigSaver) Save() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Save")
	ret0, _ := ret[0].(error)
	return ret0
}

// Save indicates an expected call of Save.
func (mr *MockConfigSaverMockRecorder) Save() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Save", reflect.TypeOf((*MockConfigSaver)(nil).Save))
}
